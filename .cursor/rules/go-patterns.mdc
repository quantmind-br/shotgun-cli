---
description: Defines Go-specific coding standards for the project, including the use of interfaces, error wrapping, structured logging with zerolog, and configuration management patterns.
globs:
  - "internal/**/*.go"
  - "cmd/**/*.go"
alwaysApply: false
---

# Go Coding Patterns & Conventions

This file outlines specific coding patterns, conventions, and best practices to follow when writing Go code for this project.

## Interface-Driven Core Logic

The `internal/core` packages are designed around interfaces to promote decoupling and testability. When interacting with core components, always use the defined interfaces.

*   **`Scanner`**: For filesystem traversal.
*   **`ContextGenerator`**: For building the LLM context.
*   **`TemplateManager`**: For handling prompt templates.
*   **`IgnoreEngine`**: For file filtering logic.

**Example**: When a command needs to scan files, it should accept a `scanner.Scanner` interface, not a concrete `scanner.FileSystemScanner`.

```go
// internal/core/scanner/scanner.go

type Scanner interface {
    Scan(rootPath string, config *ScanConfig) (*FileNode, error)
    ScanWithProgress(rootPath string, config *ScanConfig, progress chan<- Progress) (*FileNode, error)
}
```

## Error Handling

Always wrap errors with context to create a meaningful error stack. Use `fmt.Errorf` with the `%w` verb.

```go
// Good
if err != nil {
    return nil, fmt.Errorf("failed to scan directory %s: %w", rootPath, err)
}

// Bad - loses original error context
if err != nil {
    return nil, errors.New("scan failed")
}
```

## Logging

Use the `zerolog` library for structured, leveled logging. Do not use `fmt.Println` or the standard `log` package for application logging.

*   Inject the `zerolog.Logger` into components that need to log.
*   Use levels like `log.Debug()`, `log.Info()`, `log.Error()`.

## Configuration Management

Configuration is managed by Viper and initialized in `@cmd/root.go`. The `internal/config` package provides centralized configuration key constants and validation.

### Configuration Keys

Always use constants from `internal/config/keys.go` instead of hardcoded strings:

```go
import "github.com/quantmind-br/shotgun-cli/internal/config"

// Good - use typed constants
viper.GetInt(config.KeyScannerMaxFiles)
viper.GetString(config.KeyLLMProvider)

// Bad - avoid magic strings
viper.GetInt("scanner.max-files")
```

### Configuration Validation

Use `internal/config/validator.go` for validating configuration values:

```go
if !config.IsValidKey(key) {
    return fmt.Errorf("invalid key: %s", key)
}
if err := config.ValidateValue(key, value); err != nil {
    return err
}
```

### Architecture Rules

*   **DO NOT** access Viper globally from within `internal/core` or `internal/platform`.
*   **DO** pass configuration values or dedicated config structs from the `cmd` layer down to the components that need them.

```go
// cmd layer - can use viper
mgr, err := template.NewManager(template.ManagerConfig{
    CustomPath: viper.GetString(config.KeyTemplateCustomPath),
})

// internal/core layer - receives config via dependency injection
func NewManager(cfg ManagerConfig) (*Manager, error) {
    customPath := cfg.CustomPath  // Use injected value, no viper
}
```

## Application Layer Patterns (`internal/app`)

The application layer orchestrates the workflow between core components. Both the CLI (`cmd`) and TUI (`internal/ui`) should use the application layer for high-level operations.

### ContextService

Use `app.ContextService` to perform context generation. It handles scanning, selection application, generation, and saving to disk.

*   **CLI usage**: Uses `Generate()` (sync).
*   **TUI usage**: Uses `GenerateWithProgress()` to provide feedback during long-running scans or generations.

```go
svc := app.NewContextService(
    app.WithScanner(customScanner),
    app.WithGenerator(customGenerator),
)

result, err := svc.Generate(ctx, app.GenerateConfig{
    RootPath: "./",
    // ... config
})
```

### LLM Provider Registry

Always use `app.DefaultProviderRegistry` to create LLM providers. This ensures consistency across CLI and TUI.

*   **Registration**: Providers are registered in `internal/app/providers.go`.
*   **Creation**: Use `registry.Create(providerName, config)` to get a provider instance.

```go
provider, err := app.DefaultProviderRegistry.Create(llm.ProviderOpenAI, llmConfig)
```

### Progress Callback Pattern

When implementing long-running application logic, support the `ProgressCallback` pattern to allow UI layers to show progress.

```go
type ProgressCallback func(stage string, message string, current, total int64)
```

## TUI Development (`internal/ui`)

The interactive UI is built with Bubble Tea and follows the Model-View-Update (MVU) pattern.

*   **Model**: Contains the state of a component or screen.
*   **View**: Renders the UI based on the model's state.
*   **Update**: Handles incoming messages (e.g., key presses, data loading) and updates the model's state.

When working in `@internal/ui`, ensure new components and screens adhere to this pattern.
