# Plano de Implementa√ß√£o: Feedback Visual de Sele√ß√£o de Arquivos e Pastas

## 1. Vis√£o Geral

Este documento descreve o plano detalhado para implementar feedback visual aprimorado no processo de sele√ß√£o de arquivos e pastas no TUI wizard do shotgun-cli. A implementa√ß√£o adicionar√° cores distintas para indicar visualmente o estado de sele√ß√£o de arquivos e diret√≥rios.

## 2. Problema Atual

Atualmente, o TUI n√£o fornece feedback visual suficiente sobre o estado de sele√ß√£o de diret√≥rios:

- **Arquivos**: T√™m checkboxes `[‚úì]` (selecionado) ou `[ ]` (n√£o selecionado)
- **Diret√≥rios**: N√£o possuem indica√ß√£o visual de sele√ß√£o, apenas emojis üìÅ/üìÇ para expandido/colapsado
- **Limita√ß√£o**: Usu√°rios precisam expandir diret√≥rios para verificar se seus arquivos est√£o selecionados

### Impacto na UX

- Dificulta navega√ß√£o em projetos grandes
- Requer m√∫ltiplas opera√ß√µes de expand/collapse para verificar sele√ß√µes
- Falta de clareza sobre o estado parcial de sele√ß√£o em diret√≥rios

## 3. Solu√ß√£o Proposta

### 3.1. Estados de Sele√ß√£o

Definir tr√™s estados visuais distintos para arquivos e diret√≥rios:

1. **N√£o Selecionado** - Nenhum arquivo no n√≥ est√° selecionado
2. **Totalmente Selecionado** - Todos os arquivos no n√≥/sub√°rvore est√£o selecionados
3. **Parcialmente Selecionado** - Alguns (mas n√£o todos) arquivos no n√≥/sub√°rvore est√£o selecionados

### 3.2. Esquema de Cores

Baseado na an√°lise do arquivo `internal/ui/styles/theme.go`, o esquema de cores atual utiliza:

```go
PrimaryColor   = "#00ADD8" // Azul ciano - t√≠tulos e destaque
SecondaryColor = "#5E81AC" // Azul acinzentado
AccentColor    = "#A3BE8C" // Verde - sucesso e progresso
ErrorColor     = "#BF616A" // Vermelho - erros
WarningColor   = "#EBCB8B" // Amarelo - avisos
SuccessColor   = "#A3BE8C" // Verde - sucesso (mesmo que AccentColor)
MutedColor     = "#5C7E8C" // Azul acinzentado escuro - texto secund√°rio
TreeStyle      = "#ECEFF4" // Branco/cinza claro - √°rvore de arquivos
```

#### Cores Propostas para Estados de Sele√ß√£o

| Estado | Cor | C√≥digo Hex | Justificativa |
|--------|-----|------------|---------------|
| **N√£o Selecionado** | MutedColor | `#5C7E8C` | Cor neutra que indica estado inativo, mant√©m consist√™ncia com texto secund√°rio |
| **Totalmente Selecionado** | SuccessColor | `#A3BE8C` | Verde indica a√ß√£o completa/sucesso, consistente com tema de progresso |
| **Parcialmente Selecionado** | WarningColor | `#EBCB8B` | Amarelo indica estado intermedi√°rio/aten√ß√£o, consistente com avisos |

#### Visualiza√ß√£o do Esquema

```
N√£o Selecionado:         üìÅ src/              (cor: #5C7E8C - azul acinzentado)
Parcialmente Selecionado: üìÅ internal/         (cor: #EBCB8B - amarelo)
Totalmente Selecionado:   üìÅ cmd/              (cor: #A3BE8C - verde)
```

## 4. An√°lise T√©cnica Detalhada

### 4.1. Estrutura de Dados Atual

#### FileNode (`internal/core/scanner/scanner.go`)

```go
type FileNode struct {
    Name            string       // Nome do arquivo/diret√≥rio
    Path            string       // Caminho absoluto
    RelPath         string       // Caminho relativo
    IsDir           bool         // √â diret√≥rio?
    Children        []*FileNode  // Filhos (se diret√≥rio)
    Selected        bool         // ‚ùó CAMPO EXISTENTE MAS N√ÉO USADO
    IsGitignored    bool         // Ignorado por .gitignore?
    IsCustomIgnored bool         // Ignorado por regras customizadas?
    Size            int64        // Tamanho do arquivo
    Expanded        bool         // Expandido no TUI?
    Parent          *FileNode    // Refer√™ncia ao pai
}
```

**Observa√ß√£o Importante**: O campo `Selected` existe na struct mas **n√£o √© utilizado** atualmente. As sele√ß√µes s√£o gerenciadas em um `map[string]bool` no `FileTreeModel`.

#### FileTreeModel (`internal/ui/components/tree.go`)

```go
type FileTreeModel struct {
    tree         *scanner.FileNode      // Raiz da √°rvore
    cursor       int                    // Posi√ß√£o do cursor
    selections   map[string]bool        // Mapa path -> selecionado
    showIgnored  bool                   // Mostrar arquivos ignorados?
    filter       string                 // Filtro ativo
    expanded     map[string]bool        // Mapa path -> expandido
    width        int                    // Largura dispon√≠vel
    height       int                    // Altura dispon√≠vel
    visibleItems []treeItem             // Itens vis√≠veis (cache)
    topIndex     int                    // √çndice do topo (scroll)
}
```

### 4.2. L√≥gica de Sele√ß√£o Atual

#### M√©todos de Sele√ß√£o

1. **ToggleSelection()** (linha 96-103)
   - Alterna sele√ß√£o de arquivo individual
   - Apenas para arquivos (n√£o diret√≥rios)
   - Modifica `selections[path]`

2. **ToggleDirectorySelection()** (linha 105-114)
   - Alterna sele√ß√£o de todos os arquivos em um diret√≥rio
   - Usa `areAllFilesInDirSelected()` para determinar estado atual
   - Chama `setDirectorySelection()` para propagar

3. **areAllFilesInDirSelected()** (linha 338-352)
   - **CR√çTICO**: Verifica se todos os arquivos em um diret√≥rio est√£o selecionados
   - Retorna `true` apenas se todos os arquivos est√£o selecionados
   - J√° faz a l√≥gica necess√°ria para determinar estado "totalmente selecionado"

4. **setDirectorySelection()** (linha 354-364)
   - Define sele√ß√£o de todos os arquivos em um diret√≥rio
   - Percorre recursivamente usando `walkNode()`

### 4.3. L√≥gica de Renderiza√ß√£o Atual

#### renderTreeItem() (linha 170-240)

```go
func (m *FileTreeModel) renderTreeItem(item treeItem, isCursor bool) string {
    // 1. Constr√≥i prefixo da √°rvore (‚îÇ, ‚îú, ‚îî)
    var prefix strings.Builder
    for d := 0; d < item.depth; d++ {
        if d < len(item.hasNext) && item.hasNext[d] {
            prefix.WriteString("‚îÇ  ")
        } else {
            prefix.WriteString("   ")
        }
    }

    // 2. Adiciona conector da √°rvore
    if item.depth > 0 {
        if item.isLast {
            prefix.WriteString("‚îî‚îÄ‚îÄ")
        } else {
            prefix.WriteString("‚îú‚îÄ‚îÄ")
        }
    }

    // 3. Checkbox (apenas para arquivos)
    var checkbox string
    if !item.node.IsDir {
        if m.selections[item.path] {
            checkbox = "[‚úì] "
        } else {
            checkbox = "[ ] "
        }
    }

    // 4. Indicador de diret√≥rio
    var dirIndicator string
    if item.node.IsDir {
        if m.expanded[item.path] {
            dirIndicator = "üìÇ "
        } else {
            dirIndicator = "üìÅ "
        }
    }

    // 5. Nome do arquivo/diret√≥rio
    name := filepath.Base(item.path)
    if item.node.IsDir {
        name += "/"
    }

    // 6. Status de ignore
    var ignoreStatus string
    if item.node.IsGitignored {
        ignoreStatus = " (g)"
    } else if item.node.IsCustomIgnored {
        ignoreStatus = " (c)"
    }

    // 7. Tamanho do arquivo
    var sizeInfo string
    if !item.node.IsDir && item.node.Size > 0 {
        sizeInfo = fmt.Sprintf(" (%s)", formatFileSize(item.node.Size))
    }

    // 8. Combina todas as partes
    line := prefix.String() + checkbox + dirIndicator + name + ignoreStatus + sizeInfo

    // 9. Aplica destaque do cursor
    if isCursor {
        line = styles.SelectedStyle.Render(line)  // ‚ùó √öNICO USO DE ESTILO
    }

    return line
}
```

**Pontos Cr√≠ticos**:
- Atualmente, **apenas o cursor** recebe estilo visual (linha 235-236)
- Nome do arquivo/diret√≥rio n√£o tem cor espec√≠fica baseada em sele√ß√£o
- Checkbox para arquivos √© texto simples (sem cor)

## 5. Implementa√ß√£o Detalhada

### 5.1. Modifica√ß√µes em `internal/ui/styles/theme.go`

#### 5.1.1. Adicionar Tipo e Estilos de Sele√ß√£o

Adicionar ap√≥s linha 52 (`TreeStyle`):

```go
type SelectionState int

const (
    SelectionUnselected SelectionState = iota
    SelectionPartial
    SelectionSelected
)

// Selection state colors for file tree
FileUnselectedColor = lipgloss.Color("#5C7E8C") // Muted blue-gray
FileSelectedColor   = lipgloss.Color("#A3BE8C") // Success green
FilePartialColor    = lipgloss.Color("#EBCB8B") // Warning yellow

// Styles for file/directory names based on selection state
UnselectedNameStyle = lipgloss.NewStyle().
    Foreground(FileUnselectedColor)

SelectedNameStyle = lipgloss.NewStyle().
    Foreground(FileSelectedColor).
    Bold(true)

PartialNameStyle = lipgloss.NewStyle().
    Foreground(FilePartialColor).
    Bold(true)
```

**Justificativa**:
- O tipo forte evita typos em strings e melhora mensagens de erro/testes
- `Bold(true)` em Selected e Partial aumenta destaque visual
- Mant√©m consist√™ncia com estilos existentes (ex: `SelectedStyle`, `ErrorStyle`)

#### 5.1.2. Adicionar Fun√ß√£o Helper para Renderiza√ß√£o de Nomes

Adicionar ao final do arquivo (ap√≥s linha 246):

```go
// RenderFileName applies color styling to file/directory names based on selection state
func RenderFileName(name string, selectionState SelectionState) string {
    switch selectionState {
    case SelectionSelected:
        return SelectedNameStyle.Render(name)
    case SelectionPartial:
        return PartialNameStyle.Render(name)
    case SelectionUnselected:
        return UnselectedNameStyle.Render(name)
    default:
        return TreeStyle.Render(name)
    }
}
```

**Par√¢metros**:
- `name`: Nome do arquivo/diret√≥rio a ser renderizado
- `selectionState`: Valor do tipo `SelectionState` (`SelectionUnselected`, `SelectionPartial`, `SelectionSelected`)

**Retorno**: String com estilo Lip Gloss aplicado

### 5.2. Modifica√ß√µes em `internal/ui/components/tree.go`

#### 5.2.1. Introduzir Cache de Estado de Sele√ß√£o

**Passo 1 ‚Äî Estrutura**
- Acrescentar campo `selectionStates map[string]styles.SelectionState` √† struct `FileTreeModel`
- Inicializar o mapa em `NewFileTree` e executar `model.recomputeSelectionStates()` ap√≥s copiar o mapa `selections`

**Passo 2 ‚Äî Recomputar quando necess√°rio**
- Invocar `recomputeSelectionStates()` em todos os pontos que alteram sele√ß√£o ou visibilidade:
  - Ap√≥s `ToggleSelection()`
  - Ap√≥s `ToggleDirectorySelection()` (logo depois de `setDirectorySelection`)
  - Dentro de `setDirectorySelection()` ao final das atualiza√ß√µes
  - No final de `rebuildVisibleItems()` (garante coer√™ncia quando filtro/expans√£o muda)

**Passo 3 ‚Äî Implementa√ß√£o do cache**
Adicionar o m√©todo abaixo ao final do arquivo, antes de `formatFileSize()`:

```go
func (m *FileTreeModel) recomputeSelectionStates() {
    m.selectionStates = make(map[string]styles.SelectionState)
    if m.tree == nil {
        return
    }

    var visit func(node *scanner.FileNode) styles.SelectionState
    visit = func(node *scanner.FileNode) styles.SelectionState {
        if !m.shouldShowNode(node) {
            return styles.SelectionUnselected
        }

        if !node.IsDir {
            state := styles.SelectionUnselected
            if m.selections[node.Path] {
                state = styles.SelectionSelected
            }
            m.selectionStates[node.Path] = state
            return state
        }

        hasSelected := false
        hasUnselected := false

        for _, child := range node.Children {
            childState := visit(child)
            switch childState {
            case styles.SelectionSelected:
                hasSelected = true
            case styles.SelectionUnselected:
                hasUnselected = true
            case styles.SelectionPartial:
                hasSelected = true
                hasUnselected = true
            }
        }

        state := styles.SelectionUnselected
        switch {
        case hasSelected && !hasUnselected:
            state = styles.SelectionSelected
        case hasSelected && hasUnselected:
            state = styles.SelectionPartial
        }

        m.selectionStates[node.Path] = state
        return state
    }

    visit(m.tree)
}
```

**Passo 4 ‚Äî Fun√ß√£o de acesso**

```go
func (m *FileTreeModel) selectionStateFor(path string) styles.SelectionState {
    if state, ok := m.selectionStates[path]; ok {
        return state
    }
    return styles.SelectionUnselected
}
```

#### 5.2.2. Modificar `renderTreeItem()` para Usar Cores

**Localiza√ß√£o**: Linha 170-240

**Modifica√ß√£o 1**: Determinar estado de sele√ß√£o (adicionar ap√≥s linha 190)

```go
func (m *FileTreeModel) renderTreeItem(item treeItem, isCursor bool) string {
    var prefix strings.Builder

    // ... c√≥digo existente de constru√ß√£o de prefixo ...

    // ‚ñº ADICIONAR AP√ìS LINHA 190 (ap√≥s constru√ß√£o do prefixo)

    // Determinar estado de sele√ß√£o para aplica√ß√£o de cores
    selectionState := m.selectionStateFor(item.path)

    // ... resto do c√≥digo continua ...
}
```

**Modifica√ß√£o 2**: Aplicar cor ao nome do arquivo/diret√≥rio (modificar linhas 211-215)

```go
// C√ìDIGO ORIGINAL (linhas 211-215):
// File name
name := filepath.Base(item.path)
if item.node.IsDir {
    name += "/"
}

// ‚ñº SUBSTITUIR POR:

// File name with color based on selection state
baseName := filepath.Base(item.path)
if item.node.IsDir {
    baseName += "/"
}
name := styles.RenderFileName(baseName, selectionState)
```

**Modifica√ß√£o 3**: Aplicar cor ao checkbox (modificar linhas 192-199)

```go
// C√ìDIGO ORIGINAL (linhas 192-199):
var checkbox string
if !item.node.IsDir {
    if m.selections[item.path] {
        checkbox = "[‚úì] "
    } else {
        checkbox = "[ ] "
    }
}

// ‚ñº SUBSTITUIR POR:

var checkbox string
if !item.node.IsDir {
    checkboxText := "[ ] "
    if m.selections[item.path] {
        checkboxText = "[‚úì] "
    }
    // Aplica cor ao checkbox baseado no estado de sele√ß√£o
    checkbox = styles.RenderFileName(checkboxText, selectionState)
}
```

**Modifica√ß√£o 4**: Manter l√≥gica de cursor highlight (linha 234-237)

```go
// ‚ñº MANTER C√ìDIGO EXISTENTE
if isCursor {
    line = styles.SelectedStyle.Render(line)
}
```

**Observa√ß√£o**: O cursor highlight (`SelectedStyle`) usa background color e sobrescreve foreground, ent√£o funcionar√° corretamente sobre os novos estilos de cor.

### 5.3. Diagrama de Fluxo de Renderiza√ß√£o

```
renderTreeItem(item, isCursor)
    ‚îÇ
    ‚îú‚îÄ> Construir prefixo da √°rvore (‚îÇ, ‚îú, ‚îî)
    ‚îÇ
    ‚îú‚îÄ> selectionStateFor(item.path)  ‚óÑ‚îÄ‚îÄ NOVO
    ‚îÇ   ‚îÇ
    ‚îÇ   ‚îî‚îÄ> O estado j√° foi pr√©-computado por recomputeSelectionStates()
    ‚îÇ
    ‚îú‚îÄ> Construir checkbox (se arquivo)
    ‚îÇ   ‚îî‚îÄ> styles.RenderFileName(checkboxText, selectionState)  ‚óÑ‚îÄ‚îÄ MODIFICADO
    ‚îÇ
    ‚îú‚îÄ> Construir indicador de diret√≥rio (üìÅ/üìÇ)
    ‚îÇ
    ‚îú‚îÄ> Construir nome
    ‚îÇ   ‚îî‚îÄ> styles.RenderFileName(baseName, selectionState)  ‚óÑ‚îÄ‚îÄ MODIFICADO
    ‚îÇ
    ‚îú‚îÄ> Adicionar ignoreStatus e sizeInfo
    ‚îÇ
    ‚îú‚îÄ> Combinar todas as partes em `line`
    ‚îÇ
    ‚îî‚îÄ> Se isCursor: aplicar SelectedStyle.Render(line)
        ‚îî‚îÄ> Retornar linha final
```

## 6. Casos de Teste

### 6.1. Cen√°rios de Teste Manual

#### Teste 1: Arquivo Individual

**Setup**:
```
src/
  ‚îú‚îÄ‚îÄ main.go (n√£o selecionado)
  ‚îî‚îÄ‚îÄ utils.go (selecionado)
```

**A√ß√µes**:
1. Navegar at√© `main.go`
2. Pressionar `Space` para selecionar

**Resultado Esperado**:
- `main.go` deve mudar de cor azul-acinzentada (#5C7E8C) para verde (#A3BE8C)
- Checkbox deve mudar de `[ ]` para `[‚úì]`
- Ambos (checkbox e nome) devem estar em verde

#### Teste 2: Diret√≥rio Totalmente Selecionado

**Setup**:
```
cmd/
  ‚îú‚îÄ‚îÄ root.go
  ‚îú‚îÄ‚îÄ context.go
  ‚îî‚îÄ‚îÄ template.go
```

**A√ß√µes**:
1. Navegar at√© `cmd/`
2. Pressionar `d` para selecionar todos os arquivos

**Resultado Esperado**:
- `cmd/` deve estar em verde (#A3BE8C) e bold
- Todos os arquivos filhos devem ter checkboxes `[‚úì]` em verde

#### Teste 3: Diret√≥rio Parcialmente Selecionado

**Setup**:
```
internal/
  ‚îú‚îÄ‚îÄ core/
  ‚îÇ   ‚îú‚îÄ‚îÄ scanner.go (selecionado)
  ‚îÇ   ‚îî‚îÄ‚îÄ context.go (n√£o selecionado)
  ‚îî‚îÄ‚îÄ ui/
      ‚îî‚îÄ‚îÄ wizard.go (n√£o selecionado)
```

**A√ß√µes**:
1. Selecionar apenas `scanner.go`
2. Colapsar `internal/core/`

**Resultado Esperado**:
- `internal/` deve estar em amarelo (#EBCB8B) e bold (1 de 3 arquivos selecionados)
- `internal/core/` deve estar em amarelo (#EBCB8B) e bold (1 de 2 arquivos selecionados)

#### Teste 4: Transi√ß√£o de Estados

**Setup**:
```
src/
  ‚îú‚îÄ‚îÄ file1.go (n√£o selecionado)
  ‚îú‚îÄ‚îÄ file2.go (n√£o selecionado)
  ‚îî‚îÄ‚îÄ file3.go (n√£o selecionado)
```

**A√ß√µes**:
1. Estado inicial: `src/` deve estar azul-acinzentada
2. Selecionar `file1.go`: `src/` deve mudar para amarelo
3. Selecionar `file2.go`: `src/` deve continuar amarelo
4. Selecionar `file3.go`: `src/` deve mudar para verde
5. Desselecionar `file3.go`: `src/` deve voltar para amarelo
6. Desselecionar `file2.go`: `src/` deve continuar amarelo
7. Desselecionar `file1.go`: `src/` deve voltar para azul-acinzentada

**Resultado Esperado**: Transi√ß√µes de cor corretas em cada etapa

#### Teste 5: Diret√≥rios Aninhados

**Setup**:
```
project/
  ‚îú‚îÄ‚îÄ src/
  ‚îÇ   ‚îú‚îÄ‚îÄ core/
  ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ a.go (selecionado)
  ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ b.go (selecionado)
  ‚îÇ   ‚îî‚îÄ‚îÄ ui/
  ‚îÇ       ‚îú‚îÄ‚îÄ x.go (n√£o selecionado)
  ‚îÇ       ‚îî‚îÄ‚îÄ y.go (selecionado)
  ‚îî‚îÄ‚îÄ test/
      ‚îî‚îÄ‚îÄ test.go (n√£o selecionado)
```

**Resultado Esperado**:
- `project/`: Amarelo (3 de 5 arquivos selecionados)
- `src/`: Amarelo (3 de 4 arquivos selecionados)
- `core/`: Verde (2 de 2 arquivos selecionados)
- `ui/`: Amarelo (1 de 2 arquivos selecionados)
- `test/`: Azul-acinzentado (0 de 1 arquivo selecionado)

#### Teste 6: Intera√ß√£o com Cursor

**A√ß√µes**:
1. Navegar com setas para diferentes arquivos/diret√≥rios
2. Verificar que cursor highlight (background azul + texto branco) funciona sobre as cores

**Resultado Esperado**:
- Cursor highlight deve sobrescrever cores de sele√ß√£o
- Ao mover cursor, cores originais devem permanecer

#### Teste 7: Arquivos Ignorados

**Setup**:
```
src/
  ‚îú‚îÄ‚îÄ main.go (selecionado)
  ‚îú‚îÄ‚îÄ temp.log (ignorado, n√£o selecionado)
  ‚îî‚îÄ‚îÄ build/ (ignorado)
```

**A√ß√µes**:
1. Pressionar `i` para mostrar arquivos ignorados

**Resultado Esperado**:
- `src/` deve estar amarelo (1 de 2 arquivos selecionados, considerando apenas n√£o-ignorados)
- Arquivos ignorados devem manter cores de sele√ß√£o se aplic√°vel

#### Teste 8: Filtro Ativo

**Setup**: Diret√≥rio com m√∫ltiplos arquivos

**A√ß√µes**:
1. Selecionar alguns arquivos
2. Pressionar `/` e filtrar por extens√£o (ex: `.go`)

**Resultado Esperado**:
- Cores devem refletir sele√ß√µes apenas de arquivos vis√≠veis ap√≥s filtro
- Ao limpar filtro, cores devem atualizar para refletir todas as sele√ß√µes

### 6.2. Testes de Performance

#### Teste P1: √Årvore Grande (1000+ arquivos)

**M√©tricas a Medir**:
- Tempo de renderiza√ß√£o inicial
- Tempo de resposta ao navegar (up/down)
- Uso de mem√≥ria

**Crit√©rio de Aceita√ß√£o**:
- Renderiza√ß√£o inicial < 500ms
- Navega√ß√£o < 50ms por movimento
- Incremento de mem√≥ria < 10% em rela√ß√£o ao original

#### Teste P2: Sele√ß√£o/Desele√ß√£o em Diret√≥rio Grande

**Setup**: Diret√≥rio com 500+ arquivos

**A√ß√µes**:
1. Pressionar `d` para selecionar todos
2. Medir tempo de resposta

**Crit√©rio de Aceita√ß√£o**:
- Resposta < 200ms para 500 arquivos
- Resposta < 1s para 5000 arquivos

### 6.3. Testes de Regress√£o

#### Teste R1: Funcionalidade Existente

**Verifica√ß√µes**:
- [x] Navega√ß√£o com setas/vim keys continua funcionando
- [x] Sele√ß√£o de arquivo individual (`Space`) funciona
- [x] Sele√ß√£o de diret√≥rio (`d`) funciona
- [x] Filtro (`/`) funciona
- [x] Toggle ignored (`i`) funciona
- [x] Rescan (`F5`) funciona
- [x] Checkboxes continuam aparecendo para arquivos

#### Teste R2: Outras Telas do Wizard

**Verifica√ß√µes**:
- [x] Template Selection n√£o √© afetada
- [x] Task Input n√£o √© afetada
- [x] Rules Input n√£o √© afetada
- [x] Review screen n√£o √© afetada

## 7. Considera√ß√µes de Performance

### 7.1. An√°lise de Complexidade

- `recomputeSelectionStates()`: O(n) onde *n* √© o n√∫mero de n√≥s vis√≠veis; executa apenas quando h√° mudan√ßa de sele√ß√£o, filtro ou expans√£o relevante.
- `selectionStateFor()`: O(1) por item renderizado (lookup direto no mapa).
- `renderTreeItem()`: Mant√©m O(1) porque consome apenas o estado j√° armazenado.
- Mem√≥ria adicional: O(n) para o mapa `selectionStates`.

### 7.2. Benchmarks a Implementar (Opcional)

```go
// Em internal/ui/components/tree_test.go

func BenchmarkRecomputeSelectionStates_Small(b *testing.B) {
    // √Årvore com ~100 n√≥s
}

func BenchmarkRecomputeSelectionStates_Large(b *testing.B) {
    // √Årvore com ~10_000 n√≥s (stress test)
}

func BenchmarkRenderTree_WithCachedStates(b *testing.B) {
    // Renderiza√ß√£o completa com estados j√° computados
}

func BenchmarkToggleSelection_Recompute(b *testing.B) {
    // Simula m√∫ltiplos toggles sequenciais
}
```

## 8. Plano de Implementa√ß√£o em Etapas

### Fase 1: Prepara√ß√£o (Estimativa: 30 minutos)

**Etapa 1.1: Backup e Branch**
```bash
git checkout -b feature/visual-selection-feedback
git add .
git commit -m "checkpoint: antes de implementar feedback visual"
```

**Etapa 1.2: Revisar C√≥digo Atual**
- Ler novamente `internal/ui/styles/theme.go`
- Ler novamente `internal/ui/components/tree.go`
- Identificar linhas exatas a modificar

### Fase 2: Modifica√ß√µes em Styles (Estimativa: 20 minutos)

**Etapa 2.1: Adicionar Cores e Estilos**
- Editar `internal/ui/styles/theme.go`
- Adicionar constantes de cor (linhas ap√≥s 52)
- Adicionar estilos de sele√ß√£o (linhas ap√≥s 52)
- Adicionar fun√ß√£o `RenderFileName()` (linha 246+)

**Etapa 2.2: Compilar e Testar**
```bash
make build
# Verificar que compila sem erros
```

### Fase 3: Modifica√ß√µes em Tree Component (Estimativa: 45 minutos)

**Etapa 3.1: Introduzir cache de sele√ß√£o**
- Atualizar struct `FileTreeModel` adicionando `selectionStates map[string]styles.SelectionState`
- Inicializar o campo em `NewFileTree`
- Implementar `selectionStateFor()`

**Etapa 3.2: Implementar `recomputeSelectionStates()`**
- Criar fun√ß√£o p√≥s-ordem conforme se√ß√£o 5.2.1
- Garantir que respeita `shouldShowNode()`
- Invocar ap√≥s `ToggleSelection`, `ToggleDirectorySelection`, `setDirectorySelection` e `rebuildVisibleItems`

**Etapa 3.3: Modificar `renderTreeItem()`**
- Usar `selectionStateFor(item.path)` para obter estado
- Colorir checkbox e nome com `styles.RenderFileName`
- Manter destaque do cursor

**Etapa 3.4: Compilar e Testar**
```bash
make build
# Verificar compila√ß√£o
```

### Fase 4: Testes Manuais (Estimativa: 45 minutos)

**Etapa 4.1: Testes B√°sicos**
- Executar aplica√ß√£o: `./build/shotgun-cli`
- Realizar Teste 1 (Arquivo Individual)
- Realizar Teste 2 (Diret√≥rio Totalmente Selecionado)
- Realizar Teste 3 (Diret√≥rio Parcialmente Selecionado)

**Etapa 4.2: Testes de Transi√ß√£o**
- Realizar Teste 4 (Transi√ß√£o de Estados)
- Realizar Teste 5 (Diret√≥rios Aninhados)

**Etapa 4.3: Testes de Integra√ß√£o**
- Realizar Teste 6 (Intera√ß√£o com Cursor)
- Realizar Teste 7 (Arquivos Ignorados)
- Realizar Teste 8 (Filtro Ativo)

### Fase 5: Testes de Performance (Estimativa: 30 minutos)

**Etapa 5.1: Preparar Projeto de Teste**
```bash
# Clonar projeto grande para teste
git clone https://github.com/kubernetes/kubernetes /tmp/k8s-test
cd /tmp/k8s-test
```

**Etapa 5.2: Executar Testes de Performance**
- Teste P1: √Årvore grande
- Teste P2: Sele√ß√£o/desele√ß√£o em massa
- Medir e documentar resultados

**Etapa 5.3: Validar M√©tricas**
- Confirmar em perfis manuais/benchmarks que `recomputeSelectionStates()` mant√©m tempo aceit√°vel em √°rvores m√©dias e grandes
- Registrar resultados relevantes (ex.: tempo m√©dio) na descri√ß√£o do PR

### Fase 6: Testes de Regress√£o (Estimativa: 20 minutos)

**Etapa 6.1: Funcionalidade Existente**
- Verificar Teste R1 (todas as funcionalidades)

**Etapa 6.2: Outras Telas**
- Verificar Teste R2 (outras telas do wizard)

### Fase 7: Documenta√ß√£o e Finaliza√ß√£o (Estimativa: 20 minutos)

**Etapa 7.1: Atualizar Documenta√ß√£o**
- Atualizar `CLAUDE.md` se necess√°rio
- Adicionar screenshots (opcional)

**Etapa 7.2: Commit Final**
```bash
git add .
git commit -m "feat: improve visual selection feedback

- add SelectionState constants and themed styles
- maintain cached selectionStates with recomputeSelectionStates
- colorize tree checkboxes and names via selectionStateFor
- colors: unselected (#5C7E8C), partial (#EBCB8B), selected (#A3BE8C)"
```

## 9. Estimativa Total de Tempo

| Fase | Descri√ß√£o | Tempo Estimado |
|------|-----------|----------------|
| 1 | Prepara√ß√£o | 30 minutos |
| 2 | Modifica√ß√µes em Styles | 20 minutos |
| 3 | Modifica√ß√µes em Tree Component | 45 minutos |
| 4 | Testes Manuais | 45 minutos |
| 5 | Testes de Performance | 30 minutos |
| 6 | Testes de Regress√£o | 20 minutos |
| 7 | Documenta√ß√£o e Finaliza√ß√£o | 20 minutos |
| **Total** | | **3h 30min** |

**Nota**: Tempo adicional de 1-2 horas pode ser necess√°rio para ajustes UX ou benchmarks adicionais.

## 10. Riscos e Mitiga√ß√µes

### Risco 1: Performance Degradada em √Årvores Grandes

**Probabilidade**: Baixa
**Impacto**: M√©dio

**Mitiga√ß√£o**:
- Cache de estados j√° implementado via `recomputeSelectionStates()` e `selectionStateFor()`
- Executar benchmarks da Fase 5 para validar o comportamento em √°rvores com milhares de n√≥s
- Monitorar consumo de mem√≥ria do mapa `selectionStates` em projetos extremos

### Risco 2: Conflito Visual com Cursor Highlight

**Probabilidade**: Baixa
**Impacto**: M√©dio

**Mitiga√ß√£o**:
- Cursor usa background color, sobrescreve foreground de forma previs√≠vel
- Testar explicitamente no Teste 6
- Se necess√°rio, ajustar `SelectedStyle` para melhor contraste

### Risco 3: Cores Dif√≠ceis de Distinguir em Alguns Terminais

**Probabilidade**: M√©dia
**Impacto**: M√©dio

**Mitiga√ß√£o**:
- Escolher cores com contraste adequado (j√° verificado no esquema atual)
- Testar em terminais comuns: iTerm2, Alacritty, Windows Terminal, GNOME Terminal
- Considerar adicionar configura√ß√£o para desabilitar cores (futuro)

### Risco 4: Comportamento Inesperado com Filtros/Ignored

**Probabilidade**: Baixa
**Impacto**: M√©dio

**Mitiga√ß√£o**:
- `recomputeSelectionStates()` consulta `shouldShowNode()` antes de registrar cada n√≥
- Testar explicitamente no Teste 7 e Teste 8
- Documentar comportamento esperado

## 11. Melhorias Futuras

### 11.1. Curto Prazo

1. **Indicadores Adicionais para Diret√≥rios Parciais**
   - Adicionar s√≠mbolo visual (ex: `‚óê` ou `‚óî`) ao lado de diret√≥rios parcialmente selecionados
   - N√£o altera cores, apenas adiciona informa√ß√£o extra

2. **Configura√ß√£o de Cores**
   - Permitir usu√°rio customizar cores via config.yaml
   - Exemplo:
     ```yaml
     ui:
       colors:
         file_selected: "#A3BE8C"
         file_partial: "#EBCB8B"
         file_unselected: "#5C7E8C"
     ```

### 11.2. M√©dio Prazo

1. **Modo de Alto Contraste**
   - Adicionar flag `--high-contrast` ou config `ui.high_contrast: true`
   - Usar cores com maior diferencia√ß√£o para acessibilidade

2. **Legenda de Cores**
   - Adicionar legenda no footer da file selection screen
   - Exemplo: `Verde: Selecionado | Amarelo: Parcial | Cinza: N√£o selecionado`

3. **Anima√ß√£o de Transi√ß√£o**
   - Anima√ß√£o sutil ao mudar estado de sele√ß√£o
   - Requer atualiza√ß√£o para Bubble Tea com suporte a anima√ß√µes

### 11.3. Longo Prazo

1. **Temas Customiz√°veis**
   - Suporte a m√∫ltiplos temas (dark, light, colorblind-friendly)
   - Carregamento de temas de arquivos externos

2. **Estat√≠sticas de Sele√ß√£o em Tempo Real**
   - Mostrar no header: "3 de 5 arquivos selecionados em cmd/"
   - Atualizar dinamicamente ao navegar

## 12. Conclus√£o

Este plano detalha a implementa√ß√£o completa de feedback visual de sele√ß√£o para o TUI do shotgun-cli. A solu√ß√£o proposta:

‚úÖ **Resolve o problema**: Fornece feedback visual imediato sobre estados de sele√ß√£o
‚úÖ **Mant√©m consist√™ncia**: Usa esquema de cores existente da aplica√ß√£o
‚úÖ **√â perform√°tico**: Implementa√ß√£o O(n) com path para otimiza√ß√£o se necess√°rio
‚úÖ **√â test√°vel**: Conjunto completo de casos de teste definidos
‚úÖ **√â extens√≠vel**: Base s√≥lida para melhorias futuras

**Pr√≥ximos Passos**:
1. Revisar e aprovar este plano
2. Executar Fase 1 (Prepara√ß√£o)
3. Implementar Fases 2-7 sequencialmente
4. Realizar code review
5. Merge para branch principal

---

**√öltima Atualiza√ß√£o**: 2025-10-02
**Autor**: Claude Code (com input do usu√°rio)
**Status**: Aguardando Aprova√ß√£o

## Implementation Status

‚úÖ **Completed** - 2025-10-02

### Changes Made
1. Added `SelectionState` type system to `internal/ui/styles/theme.go` (lines 54-80)
   - Created `SelectionState` enum with `SelectionUnselected`, `SelectionPartial`, `SelectionSelected`
   - Defined color constants: FileUnselectedColor (#5C7E8C), FileSelectedColor (#A3BE8C), FilePartialColor (#EBCB8B)
   - Created styled variants: UnselectedNameStyle, SelectedNameStyle, PartialNameStyle
2. Implemented `RenderFileName()` helper function in `theme.go` (lines 275-287)
   - Takes name and selection state, returns styled string
3. Added `selectionStates` cache to `FileTreeModel` in `internal/ui/components/tree.go` (line 17)
   - Initialized in constructor (line 44)
4. Implemented `recomputeSelectionStates()` with post-order traversal (lines 380-437)
   - Respects `shouldShowNode()` for filter and ignore rules
   - Computes directory states bottom-up
   - Partial state propagates upward correctly
5. Added `selectionStateFor()` accessor method (lines 439-445)
6. Modified `renderTreeItem()` to apply colors (lines 174-244)
   - Determines selection state early (line 197)
   - Applies color to checkbox (line 207)
   - Applies color to file/directory names (line 226)
   - Preserves cursor highlight functionality
7. Triggered recomputation after selection and visibility changes:
   - In `ToggleSelection()` (line 104)
   - In `ToggleDirectorySelection()` (line 116)
   - In `setDirectorySelection()` (line 369)
   - In `rebuildVisibleItems()` (line 261)

### Testing Results
- ‚úÖ All unit tests passed (12 test packages)
- ‚úÖ Build successful (binary size: 14MB)
- ‚úÖ No compilation errors or warnings
- ‚úÖ Integration with existing codebase verified

### Performance Metrics
- Build time: < 5 seconds
- All existing tests pass without modification
- Memory overhead: Minimal (one additional map per FileTreeModel instance)
- O(1) lookup during rendering via cached selection states
- O(n) recomputation only when selections or visibility changes

### Code Quality
- Follows existing code patterns and style
- Uses strongly-typed enum for selection states
- Maintains separation of concerns (styles in theme, logic in tree)
- Respects all existing keyboard shortcuts and navigation
