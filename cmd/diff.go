package cmd

import (
	"bufio"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/rs/zerolog/log"
	"github.com/spf13/cobra"

	"github.com/quantmind-br/shotgun-cli/internal/core/diff"
)

var diffCmd = &cobra.Command{
	Use:   "diff",
	Short: "Diff management tools",
	Long:  "Commands for splitting and managing large diff files",
}

var diffSplitCmd = &cobra.Command{
	Use:   "split",
	Short: "Split large diff into chunks",
	Long: `Split a large diff file into smaller, manageable chunks while preserving diff context.

This command intelligently splits diff files by keeping related changes together,
ensuring that each chunk maintains proper diff headers and context. It avoids
breaking in the middle of file changes and includes appropriate chunk headers.

By default, each chunk includes metadata headers. Use --no-header to omit headers
for better patch applicability with standard patch tools.

Examples:
  shotgun-cli diff split --input large-diff.patch
  shotgun-cli diff split --input changes.diff --output-dir chunks --approx-lines 1000
  shotgun-cli diff split -i feature-branch.diff -o review-chunks --approx-lines 300
  shotgun-cli diff split --input patch.diff --no-header  # For patch tool compatibility`,

	PreRunE: func(cmd *cobra.Command, args []string) error {
		input, _ := cmd.Flags().GetString("input")
		if input == "" {
			return fmt.Errorf("input file is required")
		}

		// Check if input file exists
		if _, err := os.Stat(input); os.IsNotExist(err) {
			return fmt.Errorf("input file does not exist: %s", input)
		}

		// Check if input file is readable
		file, err := os.Open(input) //nolint:gosec // user-provided input path for diff
		if err != nil {
			return fmt.Errorf("cannot read input file '%s': %w", input, err)
		}
		_ = file.Close()

		// Validate approx-lines
		approxLines, _ := cmd.Flags().GetInt("approx-lines")
		if approxLines <= 0 {
			return fmt.Errorf("approx-lines must be positive, got: %d", approxLines)
		}

		return nil
	},
	RunE: func(cmd *cobra.Command, args []string) error {
		input, _ := cmd.Flags().GetString("input")
		outputDir, _ := cmd.Flags().GetString("output-dir")
		approxLines, _ := cmd.Flags().GetInt("approx-lines")
		noHeader, _ := cmd.Flags().GetBool("no-header")

		log.Info().
			Str("input", input).
			Str("outputDir", outputDir).
			Int("approxLines", approxLines).
			Bool("noHeader", noHeader).
			Msg("Starting diff split")

		if err := splitDiffFile(input, outputDir, approxLines, noHeader); err != nil {
			return fmt.Errorf("failed to split diff file: %w", err)
		}

		fmt.Printf("âœ… Diff file split successfully!\n")
		fmt.Printf("ðŸ“ Input file: %s\n", input)
		fmt.Printf("ðŸ“‚ Output directory: %s\n", outputDir)

		return nil
	},
}

func splitDiffFile(inputPath, outputDir string, approxLines int, noHeader bool) error {
	// Create output directory if it doesn't exist
	if err := os.MkdirAll(outputDir, 0o750); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	// Open input file - path validated by PreRunE
	file, err := os.Open(inputPath) //nolint:gosec // path validated by PreRunE
	if err != nil {
		return fmt.Errorf("failed to open input file: %w", err)
	}
	defer func() { _ = file.Close() }()

	// Read and parse diff
	scanner := bufio.NewScanner(file)
	var allLines []string
	for scanner.Scan() {
		allLines = append(allLines, scanner.Text())
	}

	if err := scanner.Err(); err != nil {
		return fmt.Errorf("failed to read input file: %w", err)
	}

	if len(allLines) == 0 {
		return fmt.Errorf("input file is empty")
	}

	log.Info().Int("totalLines", len(allLines)).Msg("Read diff file")

	chunks := diff.IntelligentSplit(allLines, diff.SplitConfig{ApproxLines: approxLines})

	log.Info().Int("chunks", len(chunks)).Msg("Split into chunks")

	// Write chunks to files
	inputBasename := strings.TrimSuffix(filepath.Base(inputPath), filepath.Ext(inputPath))

	for i, chunk := range chunks {
		chunkFilename := fmt.Sprintf("%s-chunk-%02d.diff", inputBasename, i+1)
		chunkPath := filepath.Join(outputDir, chunkFilename)

		if err := writeDiffChunk(chunkPath, chunk, i+1, len(chunks), noHeader); err != nil {
			return fmt.Errorf("failed to write chunk %d: %w", i+1, err)
		}

		fmt.Printf("ðŸ“„ Chunk %d: %s (%d lines, %d files)\n",
			i+1, chunkFilename, len(chunk.Lines), chunk.FileCount)
	}

	return nil
}

func writeDiffChunk(path string, chunk diff.Chunk, chunkNum, totalChunks int, noHeader bool) error {
	file, err := os.Create(path) //nolint:gosec // path is constructed by the tool
	if err != nil {
		return fmt.Errorf("failed to create chunk file: %w", err)
	}
	defer func() { _ = file.Close() }()

	// Conditionally write chunk header
	if !noHeader {
		_, _ = fmt.Fprintf(file, "# Diff Chunk %d of %d\n", chunkNum, totalChunks)
		_, _ = fmt.Fprintf(file, "# Generated by shotgun-cli diff split\n")
		_, _ = fmt.Fprintf(file, "# Files in this chunk: %d\n", chunk.FileCount)
		_, _ = fmt.Fprintf(file, "# Lines in this chunk: %d\n", len(chunk.Lines))
		_, _ = fmt.Fprintf(file, "#\n")
	}

	// Write diff content
	for _, line := range chunk.Lines {
		_, _ = fmt.Fprintln(file, line)
	}

	return nil
}

func init() {
	// Diff split flags
	diffSplitCmd.Flags().StringP("input", "i", "", "Input diff file (required)")
	diffSplitCmd.Flags().StringP("output-dir", "o", "chunks", "Output directory for chunks")
	diffSplitCmd.Flags().Int("approx-lines", 500, "Approximate lines per chunk")
	diffSplitCmd.Flags().Bool("no-header", false, "Omit metadata headers for better patch tool compatibility")

	// Mark input as required
	_ = diffSplitCmd.MarkFlagRequired("input")

	diffCmd.AddCommand(diffSplitCmd)
	rootCmd.AddCommand(diffCmd)
}
